'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-sign-request", 401),
  ETH_SIGNATAURE: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new bcUrRegistry.RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = bcUrRegistry.extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new bcUrRegistry.DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString("hex");
  return ethereumjsUtil.toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

bcUrRegistry.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return bcUrRegistry[k];
    }
  });
});
exports.ETHNFTItem = ETHNFTItem;
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDPathFromAddress = findHDPathFromAddress;
exports.generateAddressFromXpub = generateAddressFromXpub;
//# sourceMappingURL=bc-ur-registry-eth.cjs.development.js.map
