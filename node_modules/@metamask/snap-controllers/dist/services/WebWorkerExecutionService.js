"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebWorkerExecutionService = void 0;
const obs_store_1 = require("@metamask/obs-store");
const post_message_stream_1 = require("@metamask/post-message-stream");
const execution_environments_1 = require("@metamask/execution-environments");
const json_rpc_engine_1 = require("json-rpc-engine");
const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
const AbstractExecutionService_1 = require("./AbstractExecutionService");
class WebWorkerExecutionService extends AbstractExecutionService_1.AbstractExecutionService {
    constructor({ setupSnapProvider, workerUrl, messenger, }) {
        super({
            setupSnapProvider,
            messenger,
        });
        this.workerUrl = workerUrl;
        this.store = new obs_store_1.ObservableStore({ workers: {} });
    }
    _setWorker(workerId, workerWrapper) {
        this.jobs.set(workerId, workerWrapper);
        const newWorkerState = {
            ...this.store.getState().workers,
            [workerId]: workerWrapper,
        };
        this.store.updateState({ workers: newWorkerState });
    }
    _deleteWorker(workerId) {
        const newWorkerState = {
            ...this.store.getState().workers,
        };
        delete newWorkerState[workerId];
        this.store.updateState({ workers: newWorkerState });
    }
    _terminate(workerWrapper) {
        workerWrapper.worker.terminate();
        this._deleteWorker(workerWrapper.id);
    }
    async _initJob() {
        const workerId = (0, nanoid_1.nanoid)();
        const worker = new Worker(this.workerUrl, {
            name: workerId,
        });
        // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.
        const errorHandler = (ev) => {
            if (this._messenger) {
                const snapId = this.jobToSnapMap.get(workerId);
                if (snapId) {
                    this._messenger.publish('ExecutionService:unhandledError', snapId, {
                        code: ev.error.code,
                        message: ev.error.message,
                        data: ev.error.data,
                    });
                }
            }
        };
        worker.addEventListener('error', errorHandler, { once: true });
        const streams = this._initWorkerStreams(worker, workerId);
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        const jsonRpcConnection = (0, json_rpc_middleware_stream_1.createStreamMiddleware)();
        (0, pump_1.default)(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);
        rpcEngine.push(jsonRpcConnection.middleware);
        const workerWrapper = {
            id: workerId,
            streams,
            rpcEngine,
            worker,
        };
        this._setWorker(workerId, workerWrapper);
        await this._command(workerId, {
            jsonrpc: '2.0',
            method: 'ping',
            id: (0, nanoid_1.nanoid)(),
        });
        return workerWrapper;
    }
    _initWorkerStreams(worker, workerId) {
        const workerStream = new post_message_stream_1.WorkerParentPostMessageStream({ worker });
        // Typecast justification: stream type mismatch
        const mux = (0, AbstractExecutionService_1.setupMultiplex)(workerStream, `Worker:${workerId}`);
        const commandStream = mux.createStream(execution_environments_1.SNAP_STREAM_NAMES.COMMAND);
        const rpcStream = mux.createStream(execution_environments_1.SNAP_STREAM_NAMES.JSON_RPC);
        // Typecast: stream type mismatch
        return {
            command: commandStream,
            rpc: rpcStream,
            _connection: workerStream,
        };
    }
}
exports.WebWorkerExecutionService = WebWorkerExecutionService;
//# sourceMappingURL=WebWorkerExecutionService.js.map